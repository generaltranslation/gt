---
title: translateMany()
description: API Reference for the GT translateMany method for batch translations
---

## Overview

The `translateMany()` method efficiently translates multiple content items in a single API request. It's optimized for batch processing and provides better performance than multiple individual `translate()` calls.

```typescript
const gt = new GT({
  apiKey: 'your-api-key',
  projectId: 'your-project-id'
});

const result = await gt.translateMany([
  { source: 'Hello, world!' },
  { source: 'Welcome to our app' },
  { source: 'Click here to continue' }
], { targetLocale: 'es' });
```

This method is ideal for translating navigation menus, form labels, error messages, or any collection of related content.

<Callout>
**Performance Benefits:**
`translateMany()` reduces API overhead by batching multiple translations into a single request, making it significantly more efficient than multiple `translate()` calls.
</Callout>

---

## Reference

### Parameters

<TypeTable
  type={{
    "sources": {
      type: 'Entry[]',
      optional: false,
    },
    "globalMetadata?": {
      type: '{ targetLocale: string } & EntryMetadata',
      optional: true,
    }
  }}
/>

### Parameters Description

| Parameter | Description |
|-----------|-------------|
| `sources` | Array of `Entry` objects containing source content and optional per-item metadata |
| `globalMetadata` | Global metadata applied to all entries, including the required `targetLocale` |

### Entry Object Structure

Each entry in the `sources` array can contain:

```typescript
interface Entry {
  source: Content;           // The content to translate
  targetLocale?: string;     // Override global target locale
  context?: string;          // Translation context for this entry
  tags?: string[];          // Tags for categorization
  // ... other EntryMetadata properties
}
```

### Returns

```typescript
Promise<TranslateManyResult>
```

The result contains translated entries and any error information:

```typescript
interface TranslateManyResult {
  translations: Array<TranslationResult | TranslationError>;
  metadata: {
    totalRequests: number;
    successCount: number;
    errorCount: number;
    processingTime: number;
  };
}
```

---

## Behavior

### Global vs Per-Item Metadata

- **Global metadata** is applied to all entries as defaults
- **Per-item metadata** overrides global settings for specific entries
- Target locale can be overridden per entry

### Error Handling Strategy

- Individual translation failures don't stop the entire batch
- Each result indicates success or failure independently  
- Partial success scenarios are fully supported

### Locale Resolution

- Global target locale is used as default for all entries
- Per-entry target locales override the global setting
- All locales are resolved through custom mapping if configured

---

## Examples

### Basic Batch Translation

```typescript
const menuItems = await gt.translateMany([
  { source: 'Home' },
  { source: 'About' },
  { source: 'Products' },
  { source: 'Contact' }
], {
  targetLocale: 'fr',
  context: 'Navigation menu items'
});

menuItems.translations.forEach((result, index) => {
  if ('translation' in result) {
    console.log(`Item ${index}: ${result.translation}`);
  } else {
    console.error(`Item ${index} failed: ${result.error}`);
  }
});
```

### Mixed Content Types

```typescript
const mixedContent = await gt.translateMany([
  { 
    source: 'Welcome {name}!',
    context: 'Personalized greeting',
    tags: ['greeting', 'personal']
  },
  { 
    source: 'You have {count, plural, =0 {no items} =1 {one item} other {# items}}',
    context: 'Item count display'
  },
  { 
    source: 'Click {{action}} to continue',
    context: 'Button text with dynamic action'
  }
], { 
  targetLocale: 'de',
  tags: ['ui'] // Global tag applied to all
});
```

### Error Handling

```typescript
const result = await gt.translateMany([
  { source: 'Valid text' },
  { source: '' }, // Empty string might cause error
  { source: 'Another valid text' }
], { targetLocale: 'es' });

const successful = result.translations.filter(t => 'translation' in t);
const failed = result.translations.filter(t => 'error' in t);

console.log(`${successful.length} successful, ${failed.length} failed`);
console.log(`Success rate: ${result.metadata.successCount}/${result.metadata.totalRequests}`);

// Handle individual results
result.translations.forEach((translation, index) => {
  if ('error' in translation) {
    console.error(`Entry ${index} failed: ${translation.error}`);
  } else {
    console.log(`Entry ${index}: "${translation.translation}"`);
  }
});
```

---

## Performance Considerations

- **Batch Size**: Optimal batch sizes are typically 10-50 items depending on content length
- **Memory Usage**: Large batches consume more memory; consider chunking for very large datasets
- **Network**: Single request reduces network overhead compared to individual translations
- **Rate Limiting**: Batching helps stay within API rate limits more efficiently

---

## Notes

- Each entry can override global metadata settings
- Translation failures in one entry don't affect others
- Results maintain the same order as input entries
- Method is ideal for UI text, configuration data, and structured content
- Global metadata is merged with per-entry metadata (per-entry takes precedence)

## Next Steps

- **[Learn about single translations with translate()](/docs/core/class/methods/translation/translate)**
- **[Explore Entry and EntryMetadata types](/docs/core/types/Entry)**
- **[Understand TranslateManyResult structure](/docs/core/types/TranslateManyResult)**
- **[Check file-based workflows with enqueueFiles()](/docs/core/class/methods/translation/enqueueFiles)**