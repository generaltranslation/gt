---
title: resolveCanonicalLocale()
description: API Reference for the GT resolveCanonicalLocale method
---

## Overview

The `resolveCanonicalLocale()` method converts alias locale codes to their canonical BCP-47 locale codes when custom mapping is configured. This is essential for ensuring that user-friendly locale aliases are converted to standardized locale codes for API calls and internal processing.

```typescript
const gt = new GT({
  sourceLocale: 'en',
  customMapping: {
    'simplified-chinese': { code: 'zh-CN', name: 'Simplified Chinese' },
    'traditional-chinese': { code: 'zh-TW', name: 'Traditional Chinese' },
    'arabic': { code: 'ar-SA', name: 'Arabic' }
  }
});

// Convert alias to canonical locale
const canonical = gt.resolveCanonicalLocale('simplified-chinese');
console.log(canonical); // "zh-CN"

// Regular BCP-47 codes pass through unchanged
const unchanged = gt.resolveCanonicalLocale('fr-FR');
console.log(unchanged); // "fr-FR"
```

This method ensures compatibility between user-facing locale names and standardized locale codes required by translation APIs and internationalization libraries.

<Callout>
**API Integration:**
Use this method to convert user-selected locale aliases into canonical locale codes before making API calls. This ensures your application uses standard BCP-47 codes internally while presenting friendly names to users.
</Callout>

---

## Reference

### Parameters

<TypeTable
  type={{
    "locale?": {
      type: 'string',
      optional: true,
      default: 'this.targetLocale'
    },
    "customMapping?": {
      type: 'CustomMapping',
      optional: true,
      default: 'this.customMapping'
    }
  }}
/>

### Parameters Description

| Parameter | Description |
|-----------|-------------|
| `locale` | The alias locale code to resolve to canonical form. If not provided, uses the instance's `targetLocale` |
| `customMapping` | Optional custom mapping to use instead of the instance's mapping |

### Returns

`string` - The canonical BCP-47 locale code if a mapping exists, otherwise the original locale code

### Throws

- `Error` - If no locale is provided and the instance has no `targetLocale` configured

---

## Behavior

### Resolution Process

The method follows this resolution process:
1. **Check if locale exists** - Uses `targetLocale` if no parameter provided
2. **Validate custom mapping** - Checks if the locale has a custom mapping entry
3. **Check for canonical code** - Looks for a `code` property in the mapping
4. **Return canonical or original** - Returns the canonical code or original locale

### Custom Mapping Structure

Custom mappings should have this structure:
```typescript
{
  'alias-name': {
    code: 'canonical-locale-code',  // Required for resolution
    name: 'Display Name',           // Optional
    emoji: '🏳️',                    // Optional
    // ... other properties
  }
}
```

### Fallback Behavior

- If no custom mapping exists, returns the input locale unchanged
- If mapping exists but has no `code` property, returns the input locale
- Maintains backward compatibility with standard BCP-47 locale codes

---

## Examples

### Basic Canonical Resolution

```typescript
const gt = new GT({
  sourceLocale: 'en-US',
  customMapping: {
    'english': { code: 'en-US', name: 'English' },
    'spanish': { code: 'es-ES', name: 'Español' },
    'chinese': { code: 'zh-CN', name: '中文' },
    'arabic': { code: 'ar-SA', name: 'العربية' }
  }
});

// Resolve aliases to canonical locales
console.log(gt.resolveCanonicalLocale('english')); // "en-US"
console.log(gt.resolveCanonicalLocale('spanish')); // "es-ES"
console.log(gt.resolveCanonicalLocale('chinese')); // "zh-CN"
console.log(gt.resolveCanonicalLocale('arabic')); // "ar-SA"

// Standard locale codes pass through unchanged
console.log(gt.resolveCanonicalLocale('fr-FR')); // "fr-FR"
console.log(gt.resolveCanonicalLocale('de-DE')); // "de-DE"
```

### User Interface to API Integration

```typescript
// Example: Converting user selection to API-compatible locale
const gt = new GT({
  sourceLocale: 'en-US',
  customMapping: {
    'simplified-chinese': { code: 'zh-CN', name: 'Simplified Chinese' },
    'traditional-chinese': { code: 'zh-TW', name: 'Traditional Chinese' },
    'brazilian-portuguese': { code: 'pt-BR', name: 'Portuguese (Brazil)' },
    'european-portuguese': { code: 'pt-PT', name: 'Portuguese (Portugal)' }
  }
});

// Simulate user selecting from a dropdown
const userSelection = 'simplified-chinese';

// Convert to canonical for API call
const canonicalLocale = gt.resolveCanonicalLocale(userSelection);
console.log('API locale:', canonicalLocale); // "zh-CN"

// Use canonical locale for translation
async function translateForUser(content: string, userLocaleChoice: string) {
  const canonicalLocale = gt.resolveCanonicalLocale(userLocaleChoice);
  
  try {
    const result = await gt.translate(content, canonicalLocale);
    return {
      originalChoice: userLocaleChoice,
      canonicalLocale,
      translation: result
    };
  } catch (error) {
    throw new Error(`Translation failed for ${userLocaleChoice} (${canonicalLocale}): ${error.message}`);
  }
}

// Usage
const translation = await translateForUser('Hello World', 'simplified-chinese');
console.log(translation);
// {
//   originalChoice: 'simplified-chinese',
//   canonicalLocale: 'zh-CN', 
//   translation: { content: '你好世界', ... }
// }
```

### Default Target Locale Resolution

```typescript
const gt = new GT({
  targetLocale: 'my-custom-locale',
  customMapping: {
    'my-custom-locale': { code: 'zh-CN', name: 'My Custom Chinese' }
  }
});

// Resolve default target locale
const canonical = gt.resolveCanonicalLocale(); // Uses targetLocale
console.log(canonical); // "zh-CN"

// Explicit locale parameter
const explicit = gt.resolveCanonicalLocale('my-custom-locale');
console.log(explicit); // "zh-CN"
```

### Batch Locale Resolution

```typescript
const gt = new GT({
  customMapping: {
    'english': { code: 'en-US' },
    'spanish': { code: 'es-ES' },
    'french': { code: 'fr-FR' },
    'german': { code: 'de-DE' },
    'chinese': { code: 'zh-CN' }
  }
});

function batchResolveCanonicalLocales(locales: string[]): string[] {
  return locales.map(locale => gt.resolveCanonicalLocale(locale));
}

// Convert multiple aliases at once
const userSelections = ['english', 'chinese', 'fr-FR', 'spanish'];
const canonicalLocales = batchResolveCanonicalLocales(userSelections);
console.log(canonicalLocales); // ["en-US", "zh-CN", "fr-FR", "es-ES"]

// Use for bulk operations
async function translateToMultipleLocales(content: string, localeAliases: string[]) {
  const canonicalLocales = batchResolveCanonicalLocales(localeAliases);
  
  const translations = await Promise.all(
    canonicalLocales.map(async (locale, index) => ({
      alias: localeAliases[index],
      canonical: locale,
      result: await gt.translate(content, locale)
    }))
  );
  
  return translations;
}
```

### Custom Mapping Override

```typescript
const gt = new GT({
  customMapping: {
    'default-chinese': { code: 'zh-CN', name: 'Default Chinese' }
  }
});

// Use instance mapping
console.log(gt.resolveCanonicalLocale('default-chinese')); // "zh-CN"

// Note: Method signature supports override but uses instance mapping
// For true override, use the standalone function:
import { resolveCanonicalLocale } from 'generaltranslation';

const customOverride = {
  'override-chinese': { code: 'zh-TW', name: 'Override Chinese' }
};

// This would work with the standalone function
// const overridden = resolveCanonicalLocale('override-chinese', customOverride);
```

---

## Error Handling

### Missing Target Locale

```typescript
const gt = new GT(); // No target locale configured

try {
  // No parameter and no target locale
  const result = gt.resolveCanonicalLocale();
} catch (error) {
  console.error('Resolution failed:', error.message);
  // Error: No target locale provided for resolveCanonicalLocale
}
```

### Safe Resolution with Validation

```typescript
function safeResolveCanonical(
  gt: GT, 
  locale?: string,
  fallback: string = 'en-US'
): { canonical: string; wasResolved: boolean; error?: string } {
  try {
    if (!locale) {
      if (!gt.targetLocale) {
        return {
          canonical: fallback,
          wasResolved: false,
          error: 'No locale provided and no target locale configured'
        };
      }
      locale = gt.targetLocale;
    }
    
    const canonical = gt.resolveCanonicalLocale(locale);
    const wasResolved = canonical !== locale;
    
    return {
      canonical,
      wasResolved
    };
  } catch (error) {
    return {
      canonical: fallback,
      wasResolved: false,
      error: error.message
    };
  }
}

// Usage with validation
const gt = new GT({
  targetLocale: 'my-locale',
  customMapping: {
    'my-locale': { code: 'zh-CN', name: 'My Locale' }
  }
});

console.log(safeResolveCanonical(gt)); // { canonical: "zh-CN", wasResolved: true }
console.log(safeResolveCanonical(gt, 'fr-FR')); // { canonical: "fr-FR", wasResolved: false }
```

### Robust Locale Processing

```typescript
interface LocaleResolution {
  input: string;
  canonical: string;
  isAlias: boolean;
  isValid: boolean;
  displayName: string;
}

function processLocaleWithResolution(gt: GT, locale: string): LocaleResolution {
  try {
    const canonical = gt.resolveCanonicalLocale(locale);
    const isAlias = canonical !== locale;
    const isValid = gt.isValidLocale(canonical);
    const displayName = gt.getLocaleName(locale);
    
    return {
      input: locale,
      canonical,
      isAlias,
      isValid,
      displayName
    };
  } catch (error) {
    console.warn(`Failed to process locale ${locale}:`, error.message);
    return {
      input: locale,
      canonical: locale,
      isAlias: false,
      isValid: false,
      displayName: locale
    };
  }
}

// Usage
const gt = new GT({
  customMapping: {
    'chinese': { code: 'zh-CN', name: 'Chinese' },
    'invalid-alias': { name: 'Invalid' } // No code property
  }
});

const results = [
  processLocaleWithResolution(gt, 'chinese'),      // Valid alias
  processLocaleWithResolution(gt, 'zh-CN'),        // Direct canonical
  processLocaleWithResolution(gt, 'invalid-alias'), // Invalid alias
  processLocaleWithResolution(gt, 'nonexistent')   // Nonexistent
];

console.log(results);
```

---

## Integration Patterns

### Translation Workflow

```typescript
class TranslationService {
  constructor(private gt: GT) {}
  
  async translateContent(content: string, userLocale: string) {
    // Step 1: Resolve user locale to canonical
    const canonicalLocale = this.gt.resolveCanonicalLocale(userLocale);
    
    // Step 2: Validate the canonical locale
    if (!this.gt.isValidLocale(canonicalLocale)) {
      throw new Error(`Invalid canonical locale: ${canonicalLocale} (from ${userLocale})`);
    }
    
    // Step 3: Check if translation is needed
    if (!this.gt.requiresTranslation(this.gt.sourceLocale, canonicalLocale)) {
      return {
        content,
        locale: userLocale,
        canonical: canonicalLocale,
        translated: false
      };
    }
    
    // Step 4: Perform translation with canonical locale
    const result = await this.gt.translate(content, canonicalLocale);
    
    return {
      content: result.content,
      locale: userLocale,
      canonical: canonicalLocale,
      translated: true,
      metadata: result
    };
  }
}

// Usage
const gt = new GT({
  sourceLocale: 'en-US',
  customMapping: {
    'chinese': { code: 'zh-CN', name: 'Chinese' },
    'spanish': { code: 'es-ES', name: 'Spanish' }
  }
});

const service = new TranslationService(gt);
const result = await service.translateContent('Hello World', 'chinese');
console.log(result);
// {
//   content: '你好世界',
//   locale: 'chinese',
//   canonical: 'zh-CN',
//   translated: true,
//   metadata: { ... }
// }
```

### Locale Configuration Builder

```typescript
interface LocaleConfig {
  alias: string;
  canonical: string;
  displayName: string;
  isDefault: boolean;
}

class LocaleConfigBuilder {
  private configs: LocaleConfig[] = [];
  
  constructor(private gt: GT) {}
  
  addLocale(alias: string, isDefault: boolean = false): this {
    const canonical = this.gt.resolveCanonicalLocale(alias);
    const displayName = this.gt.getLocaleName(alias);
    
    this.configs.push({
      alias,
      canonical,
      displayName,
      isDefault
    });
    
    return this;
  }
  
  getConfigs(): LocaleConfig[] {
    return [...this.configs];
  }
  
  getDefaultConfig(): LocaleConfig | undefined {
    return this.configs.find(config => config.isDefault);
  }
  
  getCanonicalLocales(): string[] {
    return this.configs.map(config => config.canonical);
  }
}

// Usage
const gt = new GT({
  customMapping: {
    'english': { code: 'en-US', name: 'English' },
    'chinese': { code: 'zh-CN', name: 'Chinese' },
    'spanish': { code: 'es-ES', name: 'Spanish' }
  }
});

const builder = new LocaleConfigBuilder(gt)
  .addLocale('english', true)
  .addLocale('chinese')
  .addLocale('spanish');

const configs = builder.getConfigs();
const canonicalLocales = builder.getCanonicalLocales();
console.log('Available locales:', canonicalLocales); // ['en-US', 'zh-CN', 'es-ES']
```

---

## Performance Considerations

- **No Caching**: Each call performs a fresh lookup in the custom mapping
- **Minimal Processing**: Simple property access with fallback logic
- **Memory Efficient**: No internal state or caching overhead
- **Validation Cost**: Consider caching results if called frequently with same inputs

```typescript
// Performance optimization for frequent lookups
class CanonicalLocaleCache {
  private cache = new Map<string, string>();
  
  constructor(private gt: GT) {}
  
  resolve(locale: string): string {
    if (!this.cache.has(locale)) {
      this.cache.set(locale, this.gt.resolveCanonicalLocale(locale));
    }
    return this.cache.get(locale)!;
  }
  
  preload(locales: string[]): void {
    locales.forEach(locale => this.resolve(locale));
  }
  
  clear(): void {
    this.cache.clear();
  }
  
  size(): number {
    return this.cache.size;
  }
}

// Usage
const gt = new GT({ /* custom mapping */ });
const cache = new CanonicalLocaleCache(gt);

// Preload frequently used locales
cache.preload(['english', 'chinese', 'spanish']);

// Fast subsequent access
console.log(cache.resolve('english')); // Fast - cached
console.log(cache.resolve('chinese')); // Fast - cached
```

---

## Notes

- Converts alias locale codes to canonical BCP-47 locale codes
- Returns original locale if no custom mapping exists
- Essential for API compatibility when using custom locale aliases
- Works with the `customMapping` configuration from the GT constructor
- No validation is performed on the input or output locale codes
- Maintains backward compatibility with standard BCP-47 codes
- Used internally by translation methods to ensure canonical locale codes

## Next Steps

- **[Resolve back to aliases with resolveAliasLocale()](/docs/core/class/methods/locales/resolveAliasLocale)**
- **[Validate locales with isValidLocale()](/docs/core/class/methods/locales/isValidLocale)**
- **[Standardize locale format with standardizeLocale()](/docs/core/class/methods/locales/standardizeLocale)**
- **[Get locale properties with getLocaleProperties()](/docs/core/class/methods/locales/getLocaleProperties)**