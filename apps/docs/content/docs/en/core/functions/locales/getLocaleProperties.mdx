---
title: getLocaleProperties()
description: API Reference for the standalone getLocaleProperties function
---

## Overview

The standalone `getLocaleProperties()` function retrieves comprehensive properties for a locale code without requiring a GT class instance. It provides detailed information including display names, region codes, script information, and emoji flags in a complete `LocaleProperties` object.

```typescript
import { getLocaleProperties } from 'generaltranslation';

const props = getLocaleProperties('fr-CA', 'en');
console.log(props.name); // "French (Canada)"
console.log(props.nativeName); // "français (Canada)"
console.log(props.emoji); // "🇨🇦"
console.log(props.regionCode); // "CA"
```

This function is perfect for building locale selectors, internationalized components, or any situation where you need comprehensive locale metadata without maintaining GT class state.

<Callout>
**Lightweight Comprehensive Utility:**
This standalone function provides the complete `LocaleProperties` interface without class overhead, making it ideal for utility libraries, components, and situations where you need rich locale data without state management.
</Callout>

---

## Reference

### Parameters

<TypeTable
  type={{
    "locale": {
      type: 'string',
      optional: false,
    },
    "defaultLocale?": {
      type: 'string',
      optional: true,
    },
    "customMapping?": {
      type: 'CustomMapping',
      optional: true,
    }
  }}
/>

### Parameters Description

| Parameter | Description |
|-----------|-------------|
| `locale` | BCP-47 locale code to get properties for |
| `defaultLocale` | Locale to use for localizing display names (defaults to 'en') |
| `customMapping` | Optional custom mapping for locale codes and properties |

### Returns

`LocaleProperties` - A comprehensive object containing all locale information:

- `code`: Standardized locale code
- `name`: Display name in default locale
- `nativeName`: Display name in the locale itself
- `languageCode`, `languageName`, `nativeLanguageName`: Language information
- `regionCode`, `regionName`, `nativeRegionName`: Region information  
- `scriptCode`, `scriptName`, `nativeScriptName`: Script information
- `maximizedCode`, `minimizedCode`: Canonical forms
- `nameWithRegionCode`, `nativeNameWithRegionCode`: Combined display formats
- `emoji`: Flag or representative emoji

---

## Behavior

### Display Language Resolution

The function localizes names using this priority:
1. `defaultLocale` parameter (for `name`, `languageName`, `regionName`, `scriptName`)
2. Native locale itself (for `nativeName`, `nativeLanguageName`, etc.)
3. Library default locale ('en') as fallback

### Custom Mapping Integration

- Custom mappings are checked first for all properties
- Supports alias resolution and property overrides
- Falls back to standard Intl APIs for unmapped codes
- Canonical locale resolution for aliased locales

### Code Processing Strategy

1. **Custom mapping lookup** (highest priority)
2. **Intl.Locale standardization** and property extraction
3. **Intl.DisplayNames** resolution in specified locales
4. **Fallback data generation** for invalid codes

---

## Examples

### Basic Usage

```typescript
import { getLocaleProperties } from 'generaltranslation';

// English display names
const enProps = getLocaleProperties('es-MX', 'en');
console.log(enProps.name); // "Spanish (Mexico)"
console.log(enProps.languageName); // "Spanish"
console.log(enProps.regionName); // "Mexico"
console.log(enProps.emoji); // "🇲🇽"

// French display names
const frProps = getLocaleProperties('es-MX', 'fr');
console.log(frProps.name); // "espagnol (Mexique)"
console.log(frProps.languageName); // "espagnol"
console.log(frProps.regionName); // "Mexique"

// Native names are always in the target locale
console.log(enProps.nativeName); // "español (México)"
console.log(frProps.nativeName); // "español (México)"
```

### Building Locale Selector Components

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface LocaleOption {
  code: string;
  displayName: string;
  nativeName: string;
  flag: string;
  isRTL: boolean;
}

function createLocaleOptions(locales: string[], displayLocale = 'en'): LocaleOption[] {
  return locales.map(locale => {
    const props = getLocaleProperties(locale, displayLocale);
    
    return {
      code: props.code,
      displayName: props.name,
      nativeName: props.nativeName,
      flag: props.emoji,
      isRTL: isRTLLocale(locale) // Assume this helper exists
    };
  });
}

// Create options for different display languages
const englishOptions = createLocaleOptions([
  'en-US', 'es-ES', 'fr-FR', 'de-DE', 'ja-JP', 'zh-CN', 'ar-SA'
], 'en');

const spanishOptions = createLocaleOptions([
  'en-US', 'es-ES', 'fr-FR', 'de-DE', 'ja-JP', 'zh-CN', 'ar-SA'  
], 'es');

console.log(englishOptions);
// [
//   { code: 'en-US', displayName: 'English (United States)', nativeName: 'English (United States)', flag: '🇺🇸', isRTL: false },
//   { code: 'es-ES', displayName: 'Spanish (Spain)', nativeName: 'español (España)', flag: '🇪🇸', isRTL: false },
//   // ...
// ]
```

### Locale Analysis Utility

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface LocaleAnalysis {
  input: string;
  standardized: string;
  hierarchy: {
    language: string;
    region?: string;
    script?: string;
  };
  variations: {
    minimized: string;
    maximized: string;
  };
  displayNames: {
    english: string;
    native: string;
    withRegion: string;
  };
  visual: {
    emoji: string;
    textDirection: 'ltr' | 'rtl';
  };
}

function analyzeLocale(locale: string): LocaleAnalysis {
  const props = getLocaleProperties(locale, 'en');
  
  return {
    input: locale,
    standardized: props.code,
    hierarchy: {
      language: props.languageName,
      region: props.regionName || undefined,
      script: props.scriptName || undefined
    },
    variations: {
      minimized: props.minimizedCode,
      maximized: props.maximizedCode
    },
    displayNames: {
      english: props.name,
      native: props.nativeName,
      withRegion: props.nameWithRegionCode
    },
    visual: {
      emoji: props.emoji,
      textDirection: ['ar', 'he', 'fa', 'ur'].includes(props.languageCode) ? 'rtl' : 'ltr'
    }
  };
}

// Analyze different locale formats
console.log(analyzeLocale('zh-Hans-CN'));
console.log(analyzeLocale('de-AT')); 
console.log(analyzeLocale('ar-SA'));
```

### Multi-language Locale Directory

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface LocaleDirectory {
  [displayLanguage: string]: {
    [localeCode: string]: {
      name: string;
      nativeName: string;
      region: string;
      flag: string;
    };
  };
}

function buildLocaleDirectory(
  supportedLocales: string[],
  displayLanguages: string[] = ['en', 'es', 'fr', 'de']
): LocaleDirectory {
  const directory: LocaleDirectory = {};
  
  displayLanguages.forEach(displayLang => {
    directory[displayLang] = {};
    
    supportedLocales.forEach(locale => {
      const props = getLocaleProperties(locale, displayLang);
      
      directory[displayLang][locale] = {
        name: props.name,
        nativeName: props.nativeName,
        region: props.regionName,
        flag: props.emoji
      };
    });
  });
  
  return directory;
}

const directory = buildLocaleDirectory([
  'en-US', 'en-GB', 'es-ES', 'es-MX', 'fr-FR', 'fr-CA', 'de-DE', 'de-AT'
]);

// Access locale names in different languages
console.log(directory['en']['es-MX'].name); // "Spanish (Mexico)"
console.log(directory['es']['es-MX'].name); // "español (México)" 
console.log(directory['fr']['es-MX'].name); // "espagnol (Mexique)"
console.log(directory['de']['es-MX'].name); // "Spanisch (Mexiko)"
```

### Advanced Custom Mapping

```typescript
import { getLocaleProperties } from 'generaltranslation';

const customMapping = {
  // Alias mapping
  'simplified-chinese': {
    code: 'zh-CN',
    name: 'Simplified Chinese',
    nativeName: '简体中文',
    emoji: '🇨🇳'
  },
  
  // Business locale
  'business-english': {
    code: 'en-US',
    name: 'Business English',
    nativeName: 'Business English',
    regionName: 'Corporate',
    emoji: '💼'
  },
  
  // Gaming locale
  'gamer-speak': {
    code: 'en-GAMING',
    name: 'Gaming English',
    nativeName: 'L33t Sp34k',
    languageName: 'Gaming',
    nativeLanguageName: 'Gaming',
    regionName: 'Virtual',
    emoji: '🎮'
  }
};

// Use custom mappings
const simplifiedProps = getLocaleProperties('simplified-chinese', 'en', customMapping);
console.log(simplifiedProps.name); // "Simplified Chinese"
console.log(simplifiedProps.nativeName); // "简体中文"
console.log(simplifiedProps.code); // "zh-CN"

const businessProps = getLocaleProperties('business-english', 'en', customMapping);
console.log(businessProps.regionName); // "Corporate"
console.log(businessProps.emoji); // "💼"

const gamerProps = getLocaleProperties('gamer-speak', 'en', customMapping);
console.log(gamerProps.languageName); // "Gaming"
console.log(gamerProps.nativeName); // "L33t Sp34k"
```

---

## Advanced Usage

### Locale Comparison Tool

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface LocaleComparison {
  locales: {
    first: LocaleProperties;
    second: LocaleProperties;
  };
  relationship: {
    sameLanguage: boolean;
    sameRegion: boolean;
    sameScript: boolean;
    relatedness: 'identical' | 'same-language' | 'different-language';
  };
  differences: {
    language?: string;
    region?: string;
    script?: string;
  };
}

function compareLocales(locale1: string, locale2: string, displayLocale = 'en'): LocaleComparison {
  const props1 = getLocaleProperties(locale1, displayLocale);
  const props2 = getLocaleProperties(locale2, displayLocale);
  
  const sameLanguage = props1.languageCode === props2.languageCode;
  const sameRegion = props1.regionCode === props2.regionCode;
  const sameScript = props1.scriptCode === props2.scriptCode;
  
  let relatedness: LocaleComparison['relationship']['relatedness'];
  if (props1.code === props2.code) {
    relatedness = 'identical';
  } else if (sameLanguage) {
    relatedness = 'same-language';
  } else {
    relatedness = 'different-language';
  }
  
  const differences: LocaleComparison['differences'] = {};
  if (!sameLanguage) {
    differences.language = `${props1.languageName} vs ${props2.languageName}`;
  }
  if (!sameRegion) {
    differences.region = `${props1.regionName || 'None'} vs ${props2.regionName || 'None'}`;
  }
  if (!sameScript) {
    differences.script = `${props1.scriptName || 'None'} vs ${props2.scriptName || 'None'}`;
  }
  
  return {
    locales: { first: props1, second: props2 },
    relationship: { sameLanguage, sameRegion, sameScript, relatedness },
    differences
  };
}

const comparison = compareLocales('zh-Hans-CN', 'zh-Hant-TW', 'en');
console.log(comparison);
```

### Locale Validation and Normalization

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface LocaleValidationResult {
  isValid: boolean;
  normalized: string;
  issues: string[];
  properties?: LocaleProperties;
}

function validateAndNormalizeLocale(locale: string, displayLocale = 'en'): LocaleValidationResult {
  const issues: string[] = [];
  let isValid = true;
  
  try {
    const props = getLocaleProperties(locale, displayLocale);
    
    // Check if we got meaningful data back
    if (props.code === locale && props.name === locale) {
      issues.push('Locale code not recognized by Intl APIs');
      isValid = false;
    }
    
    // Check for common formatting issues
    if (locale !== props.code) {
      issues.push(`Locale code normalized from "${locale}" to "${props.code}"`);
    }
    
    // Check for missing components
    if (!props.regionCode) {
      issues.push('No region specified - using language default');
    }
    
    if (!props.scriptCode && props.maximizedCode.includes('-')) {
      const scriptMatch = props.maximizedCode.match(/-([A-Z][a-z]{3})-/);
      if (scriptMatch) {
        issues.push(`Implicit script: ${scriptMatch[1]}`);
      }
    }
    
    return {
      isValid,
      normalized: props.code,
      issues,
      properties: props
    };
    
  } catch (error) {
    return {
      isValid: false,
      normalized: locale,
      issues: [`Validation failed: ${error.message}`]
    };
  }
}

// Validate various locale formats
console.log(validateAndNormalizeLocale('en_US')); // Common mistake
console.log(validateAndNormalizeLocale('zh-simplified')); // Non-standard
console.log(validateAndNormalizeLocale('invalid-locale'));
console.log(validateAndNormalizeLocale('de-DE')); // Valid
```

### Batch Locale Processing

```typescript
import { getLocaleProperties } from 'generaltranslation';

interface BatchProcessingResult {
  processed: Array<{
    input: string;
    success: boolean;
    properties?: LocaleProperties;
    error?: string;
  }>;
  summary: {
    total: number;
    successful: number;
    failed: number;
  };
}

function batchProcessLocales(
  locales: string[], 
  displayLocale = 'en',
  customMapping?: any
): BatchProcessingResult {
  const processed = locales.map(locale => {
    try {
      const properties = getLocaleProperties(locale, displayLocale, customMapping);
      return {
        input: locale,
        success: true,
        properties
      };
    } catch (error) {
      return {
        input: locale,
        success: false,
        error: error.message
      };
    }
  });
  
  const successful = processed.filter(p => p.success).length;
  const failed = processed.length - successful;
  
  return {
    processed,
    summary: {
      total: locales.length,
      successful,
      failed
    }
  };
}

// Process a large list of locales
const localeList = [
  'en-US', 'en-GB', 'es-ES', 'es-MX', 'fr-FR', 'fr-CA',
  'de-DE', 'de-AT', 'it-IT', 'pt-BR', 'pt-PT', 'ru-RU',
  'ja-JP', 'ko-KR', 'zh-CN', 'zh-TW', 'ar-SA', 'he-IL',
  'invalid-locale', 'another-bad-one'
];

const result = batchProcessLocales(localeList);
console.log(`Processed ${result.summary.total} locales: ${result.summary.successful} successful, ${result.summary.failed} failed`);

// Extract successful results
const validLocales = result.processed
  .filter(p => p.success)
  .map(p => p.properties!);
```

---

## Error Handling

### Invalid Locale Codes

```typescript
import { getLocaleProperties } from 'generaltranslation';

// Invalid locale codes return fallback data
const invalidProps = getLocaleProperties('invalid-locale');
console.log(invalidProps.code); // "invalid-locale"
console.log(invalidProps.name); // "invalid-locale"
console.log(invalidProps.emoji); // "🏳️" (default flag)

// Validate before processing
function safeGetLocaleProperties(locale: string, defaultLocale?: string): LocaleProperties | null {
  try {
    const props = getLocaleProperties(locale, defaultLocale);
    
    // Check if we got meaningful data
    if (props.code === locale && props.name === locale) {
      console.warn(`Potentially invalid locale: ${locale}`);
      return null;
    }
    
    return props;
  } catch (error) {
    console.error(`Failed to get properties for ${locale}:`, error.message);
    return null;
  }
}

const props = safeGetLocaleProperties('xyz');
if (props) {
  console.log(`Valid locale: ${props.name}`);
} else {
  console.log('Invalid or unrecognized locale');
}
```

### Graceful Degradation

```typescript
import { getLocaleProperties } from 'generaltranslation';

function getLocaleDisplayInfo(
  locale: string, 
  displayLocale = 'en',
  fallbackLocale = 'en'
): { name: string; isValid: boolean; source: string } {
  
  try {
    // Try with requested display locale
    const props = getLocaleProperties(locale, displayLocale);
    
    if (props.name !== locale) {
      return { 
        name: props.name, 
        isValid: true, 
        source: `Intl API (${displayLocale})` 
      };
    }
    
    // If that didn't work, try with fallback
    if (displayLocale !== fallbackLocale) {
      const fallbackProps = getLocaleProperties(locale, fallbackLocale);
      if (fallbackProps.name !== locale) {
        return { 
          name: fallbackProps.name, 
          isValid: true, 
          source: `Intl API (${fallbackLocale})` 
        };
      }
    }
    
    // Return the code itself as ultimate fallback
    return { 
      name: locale, 
      isValid: false, 
      source: 'Fallback (original code)' 
    };
    
  } catch (error) {
    console.error(`Error processing locale ${locale}:`, error.message);
    return { 
      name: locale, 
      isValid: false, 
      source: 'Error fallback' 
    };
  }
}

// Usage with various locales
console.log(getLocaleDisplayInfo('fr-CA')); // Valid
console.log(getLocaleDisplayInfo('invalid-locale')); // Invalid
console.log(getLocaleDisplayInfo('zh-CN', 'de')); // Valid, German display
```

### Type-Safe Property Access

```typescript
import { getLocaleProperties, LocaleProperties } from 'generaltranslation';

type SafeLocaleProperties = {
  [K in keyof LocaleProperties]: LocaleProperties[K] extends string 
    ? { value: string; isEmpty: boolean }
    : LocaleProperties[K];
};

function getSafeLocaleProperties(locale: string, displayLocale?: string): SafeLocaleProperties {
  const props = getLocaleProperties(locale, displayLocale);
  
  const safeProps = {} as SafeLocaleProperties;
  
  (Object.keys(props) as (keyof LocaleProperties)[]).forEach(key => {
    const value = props[key];
    if (typeof value === 'string') {
      (safeProps as any)[key] = {
        value,
        isEmpty: !value || value === locale
      };
    } else {
      (safeProps as any)[key] = value;
    }
  });
  
  return safeProps;
}

// Usage with safe property checking
const safeProps = getSafeLocaleProperties('de-AT');
if (!safeProps.regionName.isEmpty) {
  console.log(`Region: ${safeProps.regionName.value}`); // "Austria"
}
```

---

## Performance Considerations

- **No State Overhead**: Function calls don't maintain internal state, ideal for one-off usage
- **Intl API Caching**: Browser caches Intl objects, but first calls may be slower
- **Custom Mapping Speed**: Properties from custom mappings resolve faster than Intl APIs
- **Batch Processing**: For many locales, consider batch processing patterns

```typescript
import { getLocaleProperties } from 'generaltranslation';

// Example performance optimization for repeated calls
class LocalePropertiesCache {
  private cache = new Map<string, LocaleProperties>();
  
  get(locale: string, displayLocale = 'en', customMapping?: any): LocaleProperties {
    const cacheKey = `${locale}:${displayLocale}:${JSON.stringify(customMapping || {})}`;
    
    if (!this.cache.has(cacheKey)) {
      this.cache.set(cacheKey, getLocaleProperties(locale, displayLocale, customMapping));
    }
    
    return this.cache.get(cacheKey)!;
  }
  
  preload(locales: string[], displayLocale = 'en', customMapping?: any): void {
    locales.forEach(locale => this.get(locale, displayLocale, customMapping));
  }
  
  clear(): void {
    this.cache.clear();
  }
}

// Usage
const cache = new LocalePropertiesCache();

// Preload common locales
cache.preload(['en-US', 'es-ES', 'fr-FR', 'de-DE']);

// Fast subsequent access
console.log(cache.get('en-US').name); // Fast - cached
console.log(cache.get('es-ES').name); // Fast - cached
```

---

## Notes

- Function provides comprehensive locale data without GT class instantiation
- All display names respect the `defaultLocale` parameter for localization
- Custom mapping properties take precedence over standard Intl APIs  
- Invalid locales return fallback data with the original code rather than throwing errors
- The complete `LocaleProperties` interface is always returned
- Native names are always computed in the target locale itself
- Emoji flags follow regional conventions with diplomatic considerations

## Next Steps

- **[Explore LocaleProperties interface](/docs/core/types/LocaleProperties)** - Complete interface documentation
- **[Use GT class method getLocaleProperties()](/docs/core/class/methods/locales/getLocaleProperties)**
- **[Get simple locale names with getLocaleName()](/docs/core/functions/locales/getLocaleName)**
- **[Get locale emoji with getLocaleEmoji()](/docs/core/functions/locales/getLocaleEmoji)**
- **[Learn about CustomMapping type](/docs/core/types/CustomMapping)**