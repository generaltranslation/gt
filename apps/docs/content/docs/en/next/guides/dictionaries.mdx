---
title: Dictionaries
description: How to use traditional dictionary-based translation patterns
---

Dictionaries provide a traditional approach to organizing translations in nested objects with key-value pairs. While [`<T>` components](/docs/next/guides/jsx) are the recommended approach, dictionaries can be useful for migration from other i18n libraries or when you prefer centralized translation storage.

<Callout>
  **Recommendation:** Use [`<T>` components](/docs/next/guides/jsx) for new projects. Dictionaries are supported primarily for migration and compatibility with existing translation workflows.
</Callout>

## Dictionary vs Component Translation

### Dictionary Pattern
```tsx
// dictionary.ts
export default {
  greetings: {
    hello: 'Hello, world!',
    welcome: 'Welcome, {name}!'
  }
};

// Component usage
function MyComponent() {
  const d = useTranslations();
  return <div>{d('greetings.hello')}</div>;
}
```

### Component Pattern  
```tsx
// Direct component usage - recommended
function MyComponent() {
  return <T><div>Hello, world!</div></T>;
}
```

## Trade-offs

### Dictionary Advantages
- **Centralized storage** - All translations in one place
- **Industry standard** - Familiar pattern from other i18n libraries
- **Migration friendly** - Easy to port existing translations

### Dictionary Disadvantages  
- **Complexity** - More setup and configuration required
- **Maintainability** - Content separated from usage makes updates harder
- **Debuggability** - Harder to trace translations back to components
- **Readability** - Keys don't show actual content

## Quick Start

### Step 1: Create Dictionary
Create a dictionary file in your project root or `src` directory:

```ts title="dictionary.ts"
const dictionary = {
  greetings: {
    hello: 'Hello, world!',
    welcome: 'Welcome to our app!'
  },
  navigation: {
    home: 'Home',
    about: 'About',
    contact: 'Contact'
  }
};

export default dictionary;
```

Or use JSON format:
```json title="dictionary.json"
{
  "greetings": {
    "hello": "Hello, world!",
    "welcome": "Welcome to our app!"
  },
  "navigation": {
    "home": "Home", 
    "about": "About",
    "contact": "Contact"
  }
}
```

### Step 2: Use in Components

#### Client Components
```tsx
import { useTranslations } from 'gt-next';

function MyComponent() {
  const d = useTranslations();
  
  return (
    <div>
      <h1>{d('greetings.hello')}</h1>
      <p>{d('greetings.welcome')}</p>
    </div>
  );
}
```

#### Server Components
```tsx
import { getTranslations } from 'gt-next/server';

async function MyServerComponent() {
  const d = await getTranslations();
  
  return (
    <div>
      <h1>{d('greetings.hello')}</h1>
      <p>{d('greetings.welcome')}</p>
    </div>
  );
}
```

## Using Variables

Add variables to dictionary entries using `{variable}` syntax:

```ts title="dictionary.ts"
const dictionary = {
  user: {
    greeting: 'Hello, {name}!',
    itemCount: 'You have {count} items',
    orderTotal: 'Total: ${amount}'
  }
};
```

```tsx
function UserDashboard() {
  const d = useTranslations();
  
  return (
    <div>
      <h1>{d('user.greeting', { name: 'Alice' })}</h1>
      <p>{d('user.itemCount', { count: 5 })}</p>
      <p>{d('user.orderTotal', { amount: 99.99 })}</p>
    </div>
  );
}
```

## Using Prefixes

Scope dictionary access to specific sections using prefixes:

```ts title="dictionary.ts"
const dictionary = {
  dashboard: {
    header: {
      welcome: 'Welcome back!',
      lastLogin: 'Last login: {date}'
    },
    stats: {
      totalUsers: 'Total Users: {count}',
      activeUsers: 'Active Users: {count}'
    }
  }
};
```

```tsx
function DashboardHeader() {
  // Prefix limits access to 'dashboard.header'
  const d = useTranslations('dashboard.header');
  
  return (
    <header>
      <h1>{d('welcome')}</h1> {/* -> dashboard.header.welcome */}
      <p>{d('lastLogin', { date: 'Today' })}</p> {/* -> dashboard.header.lastLogin */}
    </header>
  );
}

function DashboardStats() {
  // Different prefix for stats section
  const d = useTranslations('dashboard.stats');
  
  return (
    <div>
      <p>{d('totalUsers', { count: 1000 })}</p> {/* -> dashboard.stats.totalUsers */}
      <p>{d('activeUsers', { count: 150 })}</p> {/* -> dashboard.stats.activeUsers */}
    </div>
  );
}
```

## Multiple Language Support

### Automatic Translation (Recommended)
Most users should use [`loadTranslations`](/docs/next/api/config/load-translations) for automatic dictionary generation:

```ts title="dictionary.ts"  
const dictionary = {
  common: {
    save: 'Save',
    cancel: 'Cancel',
    delete: 'Delete'
  },
  forms: {
    required: 'This field is required',
    email: 'Please enter a valid email'
  }
};

export default dictionary;
```

GT automatically generates translations for other languages based on your base dictionary. Run `gtx translate` to generate translations for all configured languages.

### Manual Translation Files (Migration)
For migration from other i18n libraries or manual translation management, use [`loadDictionary`](/docs/next/api/config/load-dictionary):

```ts title="src/loadDictionary.ts"
export default async function loadDictionary(locale: string) {
  const translations = await import(`../public/locales/${locale}.json`);
  return translations.default;
}
```

This loads JSON translation files from your `public/locales/` directory:
```
public/
└── locales/
    ├── es.json
    ├── fr.json
    └── de.json
```

<Callout>
  **Choose the right approach:** Use `loadTranslations` for new projects with automatic translation, or `loadDictionary` when migrating existing translation files.
</Callout>

## Production Setup

### Build Process
Add translation to your build pipeline:

```json title="package.json"
{
  "scripts": {
    "build": "gtx translate && next build"
  }
}
```

### Development vs Production Behavior
- **Development**: Dictionary entries translated on-demand with dev API key
- **Production**: All dictionary translations pre-built during build step

## Migration from Other Libraries

For detailed migration instructions from react-i18next, next-i18next, and other i18n libraries, see the [Migration Guide](/docs/next/guides/migration). The guide covers:

- Complete migration strategies
- Keeping existing dictionary files with `loadDictionary`  
- Step-by-step replacement of hooks and components
- Gradual migration approaches

## Combining with Components

Dictionaries and [`<T>` components](/docs/next/guides/jsx) can work together:

```tsx
function MixedApproach() {
  const d = useTranslations();
  
  return (
    <div>
      {/* Dictionary for simple strings */}
      <h1>{d('page.title')}</h1>
      
      {/* T component for complex JSX */}
      <T>
        <p>This is a <strong>complex message</strong> with <a href="/link">links</a>.</p>
      </T>
      
      {/* Dictionary for form labels */}
      <label>{d('forms.email')}</label>
    </div>
  );
}
```

## Next Steps

- [Languages Guide](/docs/next/guides/languages) - Configure supported languages and locale settings
- [Dynamic Content Guide](/docs/next/guides/dynamic-content) - Handle runtime translation needs
- API References:
  - [`useTranslations()` Hook](/docs/next/api/dictionary/useTranslations)
  - [`getTranslations()` Function](/docs/next/api/dictionary/getTranslations)
  - [`loadDictionary()` Function](/docs/next/api/config/load-dictionary)